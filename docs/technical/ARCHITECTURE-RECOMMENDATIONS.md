# Task Priority Lite – Project Overview and Architecture

[Google Doc](https://docs.google.com/document/d/1dduMK8sGwiWfvKa0yZDqHtEhr1724CElFMM5lQQuqwE/edit?usp=sharing)

## 1. Overall Purpose of the Project

**Task Priority Lite** is designed as a system to intake various types of information (tasks, notes, events, etc.), automatically classify them, and route each item to the appropriate destination (such as a task manager or calendar) ([task-pri-lite/docs/prd.md at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/blob/main/docs/prd.md#:~:text=The%20Input%20Processing%20System%20is,Todoist%2C%20Calendar%2C%20Markdown%20notes%2C%20etc)). In practice, this means the tool helps manage “information overload” by identifying what each input is (e.g. a to-do, an event, or reference info) and ensuring it ends up in the right place – for example, sending actionable tasks to Todoist, scheduling events on Google Calendar, or saving reference notes to a Markdown file ([task-pri-lite/docs/prd.md at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/blob/main/docs/prd.md#:~:text=The%20Input%20Processing%20System%20is,Todoist%2C%20Calendar%2C%20Markdown%20notes%2C%20etc)). The project’s goal is to streamline personal workflow by **automating classification and routing**, reducing the manual effort needed to organize tasks and information ([task-pri-lite/docs/prd.md at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/blob/main/docs/prd.md#:~:text=This%20system%20addresses%20the%20common,of%20managing%20information%20overload%20by)). It emphasizes a **clean architecture** and extensibility so that new input types or destinations can be added without disrupting the core system logic.

## 2. Programming Languages and Technologies Used

The project is primarily implemented in **TypeScript** (Node.js environment) for the main application code. The repository’s structure (e.g. presence of `tsconfig.json` and many `.ts` files) confirms TypeScript as the core language, and the README explicitly notes TypeScript as a project dependency ([task-pri-lite/README.md at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/blob/main/README.md#:~:text=,project%20dependency)). In addition, **Python** is used for the auxiliary “exporter” tools that gather data from external services. Documentation in the `docs/exporters` section indicates that the data exporter component requires Python 3.10 and uses Poetry for dependency management ([task-pri-lite/docs at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/tree/main/docs#:~:text=,for%20Google%20Calendar%20exporter)). Essentially, TypeScript handles the central application logic and CLI, while Python scripts are used to interact with external APIs (like Todoist and Google APIs) and export that data for the TypeScript app to consume. Other technologies include JSON/Markdown for data output formats and configuration, as well as standard tooling (npm/Yarn for Node, Make/Poetry for the Python side) to manage the development workflow.

## 3. Current Architecture Overview (Python Exporters vs TypeScript App)

**Architecture:** The Task Priority Lite application follows a layered _Clean Architecture_ approach. The TypeScript code is organized into layers – Core, Application, Infrastructure, and Presentation – each with specific responsibilities ([task-pri-lite/docs/prd.md at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/blob/main/docs/prd.md#:~:text=High)) ([task-pri-lite/docs/prd.md at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/blob/main/docs/prd.md#:~:text=%E2%94%82%20%20CORE%20LAYER%20%E2%94%82,%E2%94%94%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%98%20%E2%94%82%20%E2%94%82)). The **core layer** defines domain models (e.g. Task, Project) and interfaces; the **application layer** contains business logic like processors (for GTD classification, priority calculation) and managers; the **infrastructure layer** handles external interactions (storage, external services, adapters); and the **presentation layer** provides the user interface (currently a CLI, with a future REST API planned) ([task-pri-lite/docs/prd.md at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/blob/main/docs/prd.md#:~:text=1,domain%20model%20and%20business%20rules)) ([task-pri-lite/docs/prd.md at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/blob/main/docs/prd.md#:~:text=,Layer%3A%20Contains%20user%20interface%20implementations)). This design decouples business logic from external frameworks. For example, a `FileStorageService` in the infrastructure layer implements the storage interface by reading/writing to files ([github.com](https://github.com/albeorla/task-pri-lite/raw/refs/heads/main/docs/prd.md#:~:text=Coordination%20of%20domain%20objects%20%28,Design%20Principles%20The%20system)), and “adapters” are intended to connect to external systems (like Todoist or Google APIs) without impacting core logic ([github.com](https://github.com/albeorla/task-pri-lite/raw/refs/heads/main/docs/prd.md#:~:text=,Design%20Principles%20The%20system)).

**Role of Python Exporters:** In the current setup, integration with external data sources is handled outside the TypeScript application by separate Python-based exporter scripts. These **Python exporters** (part of a tool called “Planning Data Exporter”) connect to external services’ APIs – for instance, using the Todoist API or Google Calendar API – to retrieve planning data. They then output the data in a structured format (JSON, and optionally Markdown/CSV) to files in the project’s `output/` directory ([task-pri-lite/docs at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/tree/main/docs#:~:text=The%20exporters%20generate%20the%20following,output%20files)). Specifically, one Python script fetches tasks from Todoist and saves them as `output/todoist_export.json`, while another fetches Google Calendar events and tasks, saving those to `output/calendar_events.json` and `output/calendar_tasks.json` ([task-pri-lite/docs at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/tree/main/docs#:~:text=The%20exporters%20generate%20the%20following,output%20files)). These JSON files serve as the _bridge_ between the Python layer and the TypeScript application.

**Role of the TypeScript Application:** The TypeScript application then consumes those exported JSON files as input. Via its file-based storage adapter, the app reads the task and event data that the Python scripts have produced ([task-pri-lite/docs/prd.md at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/blob/main/docs/prd.md#:~:text=,Layer%3A%20Contains%20user%20interface%20implementations)). Once loaded into the TypeScript app, this data is processed through the application’s pipeline – e.g. applying GTD-based clarification, priority assignment (such as Eisenhower matrix categorization), and then routing or outputting the results. The current version routes or outputs data in a basic way (possibly logging or writing to files, or preparing results for manual entry into systems). According to the PRD, the system _does_ conceptually support routing items to destinations like Todoist or Calendar ([task-pri-lite/docs/prd.md at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/blob/main/docs/prd.md#:~:text=Classify%20inputs%20by%20nature%20%E2%9C%85,Path%20to%20automation%20clearly%20defined)), but in the MVP this is achieved via the manual exporter process. In summary, **the Python exporters handle data collection from external sources and produce JSON, while the TypeScript app ingests that data and performs the core processing and organization.** This separation was chosen to get the system working quickly (following a “Manual with Path to Automation” principle ([github.com](https://github.com/albeorla/task-pri-lite/raw/refs/heads/main/docs/prd.md#:~:text=effort%20in%20organizing%20information%20,approach%20with%20distinct%20layers%3A))), with the understanding that those manual/file-based steps will be automated in later iterations ([task-pri-lite/docs/prd.md at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/blob/main/docs/prd.md#:~:text=Classify%20inputs%20by%20nature%20%E2%9C%85,Path%20to%20automation%20clearly%20defined)).

## 4. Data Sources Supported by the Python Exporters

The Python exporter tools currently support exporting data from two main sources:

- **Todoist** – Tasks and projects from the Todoist to-do list system are retrieved via the Todoist API (using the user’s API token) and exported. The output is saved as a JSON file (`todoist_export.json`) containing all tasks/projects in a hierarchical structure ([task-pri-lite/docs at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/tree/main/docs#:~:text=The%20exporters%20generate%20the%20following,output%20files)).
- **Google Calendar** – Data from Google Calendar is exported using Google’s Calendar (and Tasks) API with appropriate OAuth credentials. This includes **Calendar Events** (meetings or scheduled events) saved to `calendar_events.json`, and **Google Tasks** (if using Google’s Tasks service, often accessed via Calendar) saved to `calendar_tasks.json` ([task-pri-lite/docs at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/tree/main/docs#:~:text=The%20exporters%20generate%20the%20following,output%20files)). Essentially, both calendar events and task entries associated with the Google account are captured.

These are the two data sources explicitly supported at present, as evidenced by the output files the exporters generate ([task-pri-lite/docs at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/tree/main/docs#:~:text=The%20exporters%20generate%20the%20following,output%20files)). The design anticipates that additional sources could be added by writing new exporter modules or adapters (for example, email, other task management apps, etc.), but Todoist and Google Calendar cover the primary use cases in the current version.

## 5. Current Data Integration Method (Python ↔ TypeScript)

The integration between the Python exporters and the TypeScript application is presently done through **file-based JSON data exchange**. In practice, the workflow is: the Python scripts run independently and write out JSON files, and then the TypeScript system reads those files as input. For example, after running the exporters, one will have files like `./output/todoist_export.json` and `./output/calendar_events.json` populated with data ([task-pri-lite/docs at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/tree/main/docs#:~:text=The%20exporters%20generate%20the%20following,output%20files)). The TypeScript app’s storage layer is configured to load data from these files (the `FileStorageService` treats the JSON outputs as its data source) ([task-pri-lite/docs/prd.md at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/blob/main/docs/prd.md#:~:text=,Layer%3A%20Contains%20user%20interface%20implementations)).

This method means there isn’t a direct runtime communication between the Python and TypeScript parts – instead, the JSON files act as an intermediate medium. The approach is simple and decoupled: as long as the file format is agreed upon, the TypeScript app can consume the data regardless of how it was produced. However, it is also a **batch/offline integration**: the data is up-to-date only as of the last export. Any new tasks or events require running the exporters again to refresh the files. The documentation explicitly notes that the MVP relies on some **manual steps** with a plan for future automation ([task-pri-lite/docs/prd.md at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/blob/main/docs/prd.md#:~:text=Classify%20inputs%20by%20nature%20%E2%9C%85,Path%20to%20automation%20clearly%20defined)). Currently, running the exporters and then running the TS app is that manual process. In summary, integration is achieved by **sharing JSON files**, which is straightforward but not real-time.

## 6. Evolution to a Service-Based Integration (REST/GraphQL)

The project’s recommended evolution is to move away from this file-based, manual integration toward a **service-based architecture** for data exchange. Instead of writing to files, the Python exporters (or their functionality) could be exposed as **services** – for example, a REST API or GraphQL endpoint that the TypeScript application (or any client) can call to fetch fresh data. In practical terms, this might mean running a small web service (in Python or another language) that serves Todoist and Calendar data on request, or integrating those data-fetching capabilities directly into the TypeScript backend via API calls. The Task Priority Lite documentation already envisions an API layer in the presentation tier (a RESTful API for the system) ([github.com](https://github.com/albeorla/task-pri-lite/raw/refs/heads/main/docs/prd.md#:~:text=External%20service%20implementations%20%28%60LangChainLLMService%60%29%20,Design%20Principles%20The%20system)), which aligns with this direction. Also, future phases mention _direct integration_ with services (e.g. directly connecting to Todoist and calendar without manual steps) ([task-pri-lite/docs/prd.md at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/blob/main/docs/prd.md#:~:text=3,performance%2C%20expand%20to%20additional%20destinations)) – using APIs is how that would be accomplished.

**Benefits of a service-based integration model:**

- **Real-time Data Sync:** The TypeScript app could request data on demand (e.g. via an HTTP GET to an exporter service) and get the latest tasks/events, rather than relying on the last exported snapshot. This ensures the system is always working with up-to-date information.
- **Elimination of Manual Steps:** A REST/GraphQL integration removes the need to run exporter scripts and manage output files by hand. The process becomes automated – the app can trigger data updates or react to changes continuously, improving automation (one of the project’s goals ([task-pri-lite/docs/prd.md at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/blob/main/docs/prd.md#:~:text=Classify%20inputs%20by%20nature%20%E2%9C%85,Path%20to%20automation%20clearly%20defined))).
- **Cleaner Architecture Boundaries:** Using services with defined APIs creates a clear contract between components. The TypeScript application doesn’t need to know how data is gathered, only how to request it via the API. This decoupling through HTTP/GraphQL endpoints makes the system more modular and maintainable (each service can be developed or scaled independently).
- **Scalability and Deployment:** Services can run on different servers or as separate processes, allowing parts of the system to scale horizontally if needed. For example, a Python service pulling calendar data could be containerized and scaled without affecting the Node.js app. It also allows the possibility of a multi-user web app in the future, where the backend would use these APIs to aggregate user data.
- **GraphQL Benefits:** If a GraphQL API is used, the client (the main app or even a frontend) could request exactly the data it needs with one query (potentially combining multiple sources). This flexible querying can reduce data transfer and allow combining Todoist + Calendar data in one call. It’s well-suited for a scenario where multiple data sources need to be unified under one query interface.

Overall, moving to a service-based integration (whether REST or GraphQL) would modernize the architecture by making data integration **on-demand and seamless**, rather than batch-oriented. It leverages web service interfaces to integrate the Python and TypeScript components more tightly, which is the natural next step after the MVP’s file-based approach. This change would fulfill the “path to automation” that was planned for after the initial manual workflow ([task-pri-lite/docs/prd.md at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/blob/main/docs/prd.md#:~:text=Classify%20inputs%20by%20nature%20%E2%9C%85,Path%20to%20automation%20clearly%20defined)), resulting in a more dynamic and user-friendly system.

## 7. Data Storage: From Local Files to Database (PostgreSQL/MongoDB)

**Current storage method:** At present, Task Priority Lite uses a file-based storage mechanism. This means any persistent data (aside from the external exports) is likely stored as local files – for example, storing processed tasks, configuration, or intermediate results in the `data/` or `output/` directories. The Clean Architecture documentation confirms a `FileStorageService` is in use as the storage implementation ([github.com](https://github.com/albeorla/task-pri-lite/raw/refs/heads/main/docs/prd.md#:~:text=Coordination%20of%20domain%20objects%20%28,Design%20Principles%20The%20system)). In an MVP scenario, this could simply be JSON files acting as a pseudo-database for tasks and their statuses.

**Proposed migration to a database:** The documentation suggests transitioning to a “proper database solution” instead of flat files ([task-pri-lite/docs/prd.md at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/blob/main/docs/prd.md#:~:text=,Add%20caching%20for%20improved%20performance)). This could be a relational database like **PostgreSQL** or a document-oriented database like **MongoDB** – both are mentioned as likely candidates for modern app storage. Moving to a database would centralize and structure the data storage. For instance, tasks, projects, and events could be stored in tables or collections, with relationships and indexes that make queries and updates more efficient.

**Rationale for using PostgreSQL/MongoDB:**

- **Data Integrity and Concurrency:** A database can handle concurrent access and ensure that multiple operations don’t conflict. As the system grows (or if multiple users/use-cases run it), file-based storage could become inconsistent or prone to corruption, whereas a DB enforces consistency.
- **Querying and Analysis:** SQL databases like PostgreSQL allow complex queries (e.g. “find all tasks due this week with high priority”) which would be difficult with raw JSON files. Even MongoDB, while NoSQL, provides querying capabilities on document fields. This makes it easier to build advanced features and reports.
- **Scalability:** Databases are built to handle large volumes of data more gracefully than plain files. If the amount of tasks and notes increases, a DB can index and retrieve them much faster. It also supports partial updates (you don’t have to rewrite an entire JSON file to change one item).
- **Multi-Platform Access:** With a proper DB, the data can be accessed by other tools or a web interface simultaneously. For example, a future web dashboard (mentioned as a potential improvement ([task-pri-lite/docs/prd.md at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/blob/main/docs/prd.md#:~:text=Presentation%20Layer%20Improvements))) could query the database for information. With file storage, concurrent or remote access is cumbersome.
- **Maintenance and Features:** Databases offer features like automated backups, transactions, and security controls. The project can leverage these instead of reinventing them. For instance, PostgreSQL would let us use transactions when processing a batch of tasks, and MongoDB could easily store JSON-like objects without a schema if flexibility is needed.

The clean architecture’s principle of **“Independence of Database”** means the core logic doesn’t depend on any one storage implementation ([task-pri-lite/docs/prd.md at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/blob/main/docs/prd.md#:~:text=,know%20anything%20about%20external%20interfaces)), so this swap can be made without affecting the higher-level processing. By moving to PostgreSQL or MongoDB, Task Priority Lite would gain robustness and scalability for its data layer. In summary, the current use of JSON files is sufficient for a prototype, but the plan is to **upgrade to a real database** (SQL or NoSQL) to better support growth, reliability, and more complex queries ([task-pri-lite/docs/prd.md at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/blob/main/docs/prd.md#:~:text=,Add%20caching%20for%20improved%20performance)).

## 8. Suggested Future Technologies (Go, Rust) and Their Roles

In the forward-looking discussions about Task Priority Lite, it has been suggested that certain components might benefit from using systems programming languages like **Go** or **Rust** in the future. The idea behind this is to improve performance, efficiency, and deployment simplicity for specific parts of the system as it evolves. Because the architecture is modular and does not tie the core to a specific technology stack ([task-pri-lite/docs/prd.md at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/blob/main/docs/prd.md#:~:text=,know%20anything%20about%20external%20interfaces)), the team has flexibility to implement components in different languages if needed.

- **Go (Golang):** Go is recommended for building high-performance, concurrent services with relative ease. In the context of Task Priority Lite, Go could be used to implement the exporter services or other backend services. For example, the current Python exporters might be eventually rewritten as a Go microservice that pulls in Todoist and Calendar data and exposes them via a REST API. Go’s strengths in simplicity, fast startup, and low resource usage would make such a service efficient and easy to deploy as a single binary. It’s well-suited for the task of continuously running background jobs or web servers that handle multiple requests (taking advantage of Go’s goroutines for concurrency). By using Go for integration services, the system could handle higher loads or more simultaneous syncing operations with minimal overhead, compared to a Python script.

- **Rust:** Rust is another suggested technology for future consideration, particularly for **performance-critical components**. Rust could be used to rewrite parts of the core logic or CLI tool where execution speed and memory safety are paramount. For instance, if the task processing (applying NLP or complex prioritization algorithms) becomes computationally intensive, a Rust implementation of that engine could run faster than the current TypeScript (Node.js) implementation. Rust’s compiled binaries and rich type system would ensure reliability (no runtime null pointer issues, etc.) and can be integrated with other languages through FFI if needed. Another area Rust could shine is building a command-line interface or local app that needs to run on various platforms quickly – a Rust-based CLI for Task Priority Lite could start instantly and use minimal memory, which is beneficial for a productivity tool that a user might invoke frequently.

The reason these languages are being looked at is largely **performance and deployment**. Both Go and Rust produce standalone executables, which simplifies deploying the tool to different environments (no need to manage a Python interpreter or Node runtime for end-users in the long run). They also offer improvements in how the application can scale: Go with its easy concurrency might handle many API calls or integrations in parallel, and Rust with its efficiency could handle heavy data processing or even embed machine learning models for smart task processing. Adopting these languages for the right components could thus increase the overall efficiency of Task Priority Lite.

It’s important to note that these are forward-thinking suggestions – the current system works with Python and TypeScript, but thanks to the clean, interface-driven architecture, swapping in a Go or Rust component in the future would not require a complete rewrite of the whole system ([task-pri-lite/docs/prd.md at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/blob/main/docs/prd.md#:~:text=,know%20anything%20about%20external%20interfaces)). Instead, they could be introduced incrementally (for example, replacing the Python exporter with a Go service, or creating a new Rust-powered module for a specific feature) without breaking the existing structure. This approach ensures that as requirements grow (more data, more users, more complexity), the technology stack can evolve to meet them, using the best tool for each job.

**Sources:**

- Project README and PRD – Purpose and overview ([task-pri-lite/docs/prd.md at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/blob/main/docs/prd.md#:~:text=The%20Input%20Processing%20System%20is,Todoist%2C%20Calendar%2C%20Markdown%20notes%2C%20etc)) ([task-pri-lite/docs/prd.md at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/blob/main/docs/prd.md#:~:text=This%20system%20addresses%20the%20common,of%20managing%20information%20overload%20by))
- Project README – Tech stack (TypeScript) ([task-pri-lite/README.md at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/blob/main/README.md#:~:text=,project%20dependency))
- Documentation – Python exporter prerequisites ([task-pri-lite/docs at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/tree/main/docs#:~:text=,for%20Google%20Calendar%20exporter))
- Documentation – Exporter output files for Todoist and Google Calendar ([task-pri-lite/docs at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/tree/main/docs#:~:text=The%20exporters%20generate%20the%20following,output%20files))
- PRD (Architecture) – Clean architecture layers and storage adapter ([github.com](https://github.com/albeorla/task-pri-lite/raw/refs/heads/main/docs/prd.md#:~:text=Coordination%20of%20domain%20objects%20%28,Design%20Principles%20The%20system)) ([task-pri-lite/docs/prd.md at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/blob/main/docs/prd.md#:~:text=,Layer%3A%20Contains%20user%20interface%20implementations))
- PRD (Requirements) – Routing to Todoist/Calendar and manual steps vs automation ([task-pri-lite/docs/prd.md at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/blob/main/docs/prd.md#:~:text=Classify%20inputs%20by%20nature%20%E2%9C%85,Path%20to%20automation%20clearly%20defined))
- PRD (Future Plans) – Direct integration phases and database migration ([task-pri-lite/docs/prd.md at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/blob/main/docs/prd.md#:~:text=3,performance%2C%20expand%20to%20additional%20destinations)) ([task-pri-lite/docs/prd.md at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/blob/main/docs/prd.md#:~:text=,Add%20caching%20for%20improved%20performance))
- PRD (Design Principles) – Independence of external agencies (flexibility for new tech) ([task-pri-lite/docs/prd.md at main · albeorla/task-pri-lite · GitHub](https://github.com/albeorla/task-pri-lite/blob/main/docs/prd.md#:~:text=,know%20anything%20about%20external%20interfaces))
